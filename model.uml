@startuml EthereumTransactionListener

skinparam classAttributeIconSize 0
skinparam linetype ortho
skinparam packageStyle rectangle

package "External Libraries" <<Cloud>> {
    class WebSocketProvider <<ethers>> {
        +websocket
        +ready
        +getNetwork()
        +getTransaction(hash)
        +on(event, listener)
        +off(event)
        +destroy()
    }

    class Kafka <<kafkajs>> {
        +producer()
    }

    class Producer <<kafkajs>> {
        +connect()
        +disconnect()
        +send(record)
    }

    class SparkSession <<pyspark>> {
        +readStream
        +writeStream
        +stop()
    }

    class KafkaSource <<spark-kafka>> {
        +format(kafka)
        +option(key, value)
        +load()
    }
}

' Configuration Types
package "Configuration Types" {
    interface EthereumListenerConfig {
        +maxConcurrentFetches: number
        +fetchTimeout: number
        +autoReconnect: boolean
        +maxReconnectAttempts: number
        +reconnectDelay: number
        +maxReconnectDelay: number
        +reconnectBackoffMultiplier: number
    }

    interface KafkaProducerConfig {
        +brokers: string[]
        +clientId: string
        +topic: string
        +compression: boolean
        +maxRetries: number
        +retryTimeout: number
    }

    interface SparkConsumerConfig {
        +kafkaBootstrapServers: string
        +kafkaTopic: string
        +consumerGroupId: string
        +startingOffsets: string
        +autoCommitEnabled: boolean
        +autoCommitIntervalMs: number
    }

    interface EnvironmentConfig {
        +ETH_WEBSOCKET_URL: string
        +MAX_CONCURRENT_FETCHES: string
        +FETCH_TIMEOUT: string
        +AUTO_RECONNECT: string
        +MAX_RECONNECT_ATTEMPTS: string
        +RECONNECT_DELAY: string
        +MAX_RECONNECT_DELAY: string
        +RECONNECT_BACKOFF_MULTIPLIER: string
        +KAFKA_BOOTSTRAP_SERVERS: string
        +CONSUMER_GROUP_ID: string
    }
}

' Data Types
package "Data Types" {
    interface NormalizedTransaction {
        +hash: string
        +blockNumber: number
        +from: string
        +to: string
        +value: string
        +gasLimit: string
        +gasPrice: string
        +maxFeePerGas: string
        +maxPriorityFeePerGas: string
        +data: string
        +nonce: number
        +type: number
        +chainId: string
        +metadata: TransactionMetadata
    }

    interface TransactionMetadata {
        +receivedAt: string
        +network: string
        +chainId: string
    }

    interface TransactionFetchResult {
        +success: boolean
        +txHash: string
        +transaction: TransactionInfo
        +error: string
    }

    interface KafkaMessageMetadata {
        +key: string
        +value: string
        +timestamp: number
    }

}

package "Core Components" {
    class EthereumWebSocketListener {
        -websocketUrl: string
        -provider: WebSocketProvider
        -isConnected: boolean
        -isListening: boolean
        -maxConcurrentFetches: number
        -fetchTimeout: number
        -ongoingFetches: Set
        -networkName: string
        -chainId: string
        -transactionCallback: TransactionCallback
        -autoReconnect: boolean
        -maxReconnectAttempts: number
        -reconnectDelay: number
        -maxReconnectDelay: number
        -reconnectBackoffMultiplier: number
        -reconnectAttempts: number
        -isReconnecting: boolean
        -reconnectTimer: Timer
        -shouldReconnect: boolean
        -wasListeningBeforeDisconnect: boolean
        -connectionId: number
        __
        +EthereumWebSocketListener(websocketUrl, config)
        +connect()
        +disconnect()
        +startListening()
        +stopListening()
        +setTransactionCallback(callback)
        +getConnectionStatus()
        +getListeningStatus()
        +getConnectionId()
        +getReconnectionState()
        -setupErrorHandlers(connectionId)
        -cleanupProvider()
        -scheduleReconnect()
        -reconnect()
        -clearReconnectTimer()
        -handlePendingTransaction(txHash)
        -fetchTransactionDetails(txHash)
    }

    class TransactionKafkaProducer {
        -kafka: Kafka
        -producer: Producer
        -topic: string
        -isConnected: boolean
        -maxRetries: number
        -retryTimeout: number
        __
        +TransactionKafkaProducer(config)
        +connect()
        +disconnect()
        +publishTransaction(transaction)
        +publishBatch(transactions)
        +getConnectionStatus()
        +getTopic()
    }

    class SparkKafkaConsumer <<python>> {
        -spark: SparkSession
        -kafkaBootstrapServers: string
        -topic: string
        -consumerGroupId: string
        -transactionSchema: StructType
        __
        +SparkKafkaConsumer(config)
        +createSparkSession()
        +getTransactionSchema()
        +consumeKafkaMessages()
        -parseMessages()
        -logToConsole()
    }
}

package "Utilities" {
    class TransactionNormalizer <<utility>> {
        +{static} normalizeTransaction(transaction, networkName, chainId)
        +{static} transactionToJSON(normalized)
        +{static} transactionToCompactJSON(normalized)
    }
}

package "Type Aliases" {
    interface TransactionCallback <<function>> {
        +call(transaction)
    }

    interface ReconnectionState {
        +isReconnecting: boolean
        +reconnectAttempts: number
        +shouldReconnect: boolean
    }
}

class Main <<entrypoint>> {
    +{static} main()
}

class SparkConsumerMain <<python-entrypoint>> {
    +{static} main()
}

' Relationships
EthereumWebSocketListener --> WebSocketProvider : uses
EthereumWebSocketListener ..> EthereumListenerConfig : configured by
EthereumWebSocketListener ..> TransactionCallback : uses
EthereumWebSocketListener ..> NormalizedTransaction : produces
EthereumWebSocketListener ..> TransactionNormalizer : calls

TransactionKafkaProducer --> Kafka : creates
TransactionKafkaProducer --> Producer : uses
TransactionKafkaProducer ..> KafkaProducerConfig : configured by
TransactionKafkaProducer ..> NormalizedTransaction : consumes
TransactionKafkaProducer ..> TransactionNormalizer : calls

SparkKafkaConsumer --> SparkSession : creates
SparkKafkaConsumer --> KafkaSource : uses
SparkKafkaConsumer ..> SparkConsumerConfig : configured by
SparkKafkaConsumer ..> NormalizedTransaction : consumes

TransactionNormalizer ..> NormalizedTransaction : creates
TransactionNormalizer ..> TransactionMetadata : creates

NormalizedTransaction *-- TransactionMetadata : contains

Main --> EthereumWebSocketListener : creates
Main --> TransactionKafkaProducer : creates
Main ..> TransactionCallback : sets

SparkConsumerMain --> SparkKafkaConsumer : creates

' Notes
note right of EthereumWebSocketListener
  Manages WebSocket connection to Ethereum RPC
  - Auto-reconnection with exponential backoff
  - Concurrency control for transaction fetches
  - Connection ID tracking for ghost session prevention
end note

note right of TransactionKafkaProducer
  Publishes normalized transactions to Kafka
  - GZIP compression
  - Idempotent producer
  - Batch publishing support
end note

note right of SparkKafkaConsumer
  Consumes transactions from Kafka using PySpark
  - Spark Structured Streaming
  - Auto-commit enabled (1s interval)
  - Schema validation
  - Console output logging
end note

note bottom of TransactionNormalizer
  Converts raw transactions to normalized format
  - Adds metadata (timestamp, network, chainId)
  - Handles both legacy and EIP-1559 transactions
end note

' Architecture Flow
note as N1
  <b>Complete Data Flow</b>
  1. EthereumWebSocketListener connects to Ethereum WebSocket
  2. Listens for pending transactions
  3. Fetches full transaction details
  4. Normalizes transaction using TransactionNormalizer
  5. Invokes TransactionCallback
  6. TransactionKafkaProducer publishes to Kafka topic
  7. SparkKafkaConsumer reads from Kafka in real-time
  8. Parses and validates transaction schema
  9. Logs to console (auto-commits offsets)
end note

@enduml
